>#####Дисклеймер!
Настоятельно рекомендую прочитать предыдущую [статью](https://github.com/Hateman31/Kivy-magazine-ru/blob/master/lessons/lesson1.md)

## Мир вашему дому!

В этой статье мы научимся связывать разметку с кодом, 
создавать собственные виджеты и разбивать разметку 
на несколько модулей. И для этого мы сделаем всего лишь калькулятор.

###Поехали!

Калькулятор сможет выполнять стандартный набор из шести функций:  
сложение,вычитание, умножение, деление, извлечение корня и возведение в степень.
Мы будем вводить число, нажимать кнопку нужной операции, 
в поле ввода писать другое число и, после нажатия клавиши enter, 
получать внутри формы результат операции. 

Операции находятся в файле *toolkit.py*. Вот содержимое этого файла:
```python
def summ(x,y):
	return x+y

def sub(x,y):
	return x-y
	
def mul(x,y):
	return x*y

def div(x,y):
	return x/y

def pow_(x,y):
	return x**y

def root_(x,y):
	return x**(1/y)

func = {
	'summBtn': summ,	'subBtn': sub,
	'mulBtn': mul,	'divBtn':div,
	'powerBtn': pow_,	'rootBtn':root_
	}
```	
Извлечение корня может работать некорректно. Эта функция лишь пример работы с Kivy, 
поэтому не обращаем на неё особого внимания.
Перейдем к самому приложению. Создаём файл calculator.py и пишем в него следующее:
```python
from kivy.app import App
from kivy.uix.boxlayout import BoxLayout
from kivy.uix.button import Button
import toolkit

class Calculator(BoxLayout):
	def operation(self):
		x = float(self.form.text)
		y = float(self.buf)
		self.form.text = str(toolkit.func[self.action](x,y))
		
class CalculatorApp(App):
	def build(self):
		return Calculator()

CalculatorApp().run()
```

Из листинга функции operation становится ясно, 
что объект Calculator будет иметь атрибуты buf 
(буфер для первого операнда) и action - ключевое слово , 
по которому будет вызвана необходимая функция из модуля toolkit.py. 
Функцию operation будем вызывать после нажатия enter внутри формы ввода.

На этом с логикой приложения закончили. Теперь создаем файл разметки — *calculator.kv* . 

###От простого к сложному

[В прошлом уроке](https://github.com/Hateman31/Kivy-magazine-ru/blob/master/lessons/lesson1.md) мы научились вводить текст в форму 
и заставляли этот текст легко  меняться по нажатию кнопки. 
Калькулятор — немного усложнённая версия этой задачи. 
Но трудного ничего нет, потому что мы уже знаем, что:

* нам нужны TextInput и Button 
* обращаться к одному виджету из другого можно, используя параметр id
* текст виджета задается через атрибут text
* действие кнопки задается через событие *on_press*

Калькулятор будет состоять из 6 кнопок и поля ввода. 
Начнём с поля ввода. TextInput по умолчанию работает в многострочном режиме. 
Чтобы отключить его, задаём свойству multiline значение False. 
Чтобы обращаться к элементу form в скрипте, 
надо создать атрибут form у виджета <Calculator> 
и записать в этот атрибут индентификатор формы.
```
	<Calculator>:
		form: form
		TextInput:
			id: form
			multiline: False
```
###Пиши раз — используй многократно

Прежде чем добавить кнопки, немного подумаем. 
Все шесть кнопок работают идентично, 
поэтому метод *on_press* мы объявим 
один раз для всех шести объектов. 
Для этого создадим файл *action.kv* и добавим в него это:
```
<ActionBtn@Button>:
    action: ''
    on_press:
        app.root.buf = app.root.form.text
        app.root.form.text = ''
        app.root.action = self.action
```
Конструкция вида ```<class_name@widget_class>```— это , так называемый, 
динамический класс. Когда для однотипных виджетов, например кнопок, 
раз за разом приходится писать похожие параметры , 
достаточно создать динамический класс, унаследованный, 
скажем, от Button(для этого после @ мы указываем родительский класс), 
задать в нём значения повторяющихся атрибутов, 
а потом вместо дефолтного виджета вписать имя созданного класса.

Теперь по нажатию любой кнопки типа *ActionBtn*, текст элемента 
form будет считываться в *root.buf*, а на его место 
ставиться пустая строка. Атрибуту action виджета *Calculator* 
будет при этом присваиваться значение атрибута action нажатой кнопки.
Но ActionBtn это самостоятельный класс, лежащий к тому же в отдельном файле.
Как же его связать с корневым виджетом *Calculator*?

В kivy есть три служебных слова: *self, app* и *root*. 
Что означают первые два - понятно. 
Третье тоже не вызывает вопросов, однако, не всё так просто.
С одной стороны, root  — это корневой виджет.  
То есть по слову root мы получаем доступ к виджету, 
который является корневым для приложения. 
С другой стороны, root — это атрибут объекта app. 

Root, как корневой виджет, работает только внутри корневого элемента.
Если использовать root внутри динамического класса, то мы обратимся 
не к корневому виджету, а экземпляру этого класса. А вот служебное слово app 
одинаково работает во всех частях приложения. В том числе в файлах разметки. 
А это значит,что любой виджет может обратиться к коревному виджету приложения как app.root.  
Даже если виджет — динамический класс. Даже если  находится в отдельном файле 
( хорошая возможность для создания собственных наборов виджетов).

Чтобы начать использовать *ActionBtn*, в начало файла *calculator.kv* добавляем строку:
```
#:include action.kv
```
Теперь добавляем кнопки в *Calculator*. Мы разместим кнопки в сетке 3x2. Для этого используем контейнер *GridLayout*: 
```
    GridLayout:
        rows: 3
        cols: 2
        ActionBtn:
            action:'summBtn'
            text:'x+y'
        ActionBtn:
            action:'subBtn'
            text:'x-y'
        ActionBtn:
            action:'mulBtn'
            text:'x*y'
        ActionBtn:
            action:'divBtn'
            text:'x/y'
        ActionBtn:
            action:'powerBtn'
            text:'x^y'
        ActionBtn:
            action:'rootBtn'
            text:'root(x,y)'
```
Кнопки готовы.

###Разделяй и властвуй

Напомню общий алгоритм работы с программой:

1. вводим первое число 
2. нажимаем кнопку (поле очищается)
3. вводим второе число
4. нажимаем enter
5. получаем результат операции(текст формы меняется)

С пунктами *1* и *2* всё ясно. Переходим к оставшимся. 
Здесь нам надо отследить нажатие *enter* в *TextInput*, 
и, если в буфере уже есть число, то вызвать функцию *operation*.

В TextInput  есть такое событие *on_text_validate* - 
реагирует на нажатие enter ( работает **только** в однострочном режиме ). 
Используем условное выражение, чтобы проверить root.buf:
```
#code before ...        
	TextInput:
        id: form
        multiline: False
        on_text_validate:
            if root.buf: root.operation()
#code after ...            
```
>##Важно !
>Kv очень трепетно отностится к отступам и переносам, 
>поэтому: если выражение короткое,пишите его в одну строку, 
>а если длинное, то не забудьте поставить бэкслэш после двоеточия, 
>а новую строку начать на том же уровне, что и условный оператор.

###Добавим красоты

Теперь когда наше детище наделено «умом», 
давайте сделаем его немного симпатичней. Предлагаю несколько улучшить внешний вид приложения. 
Для начала мы «отлепим» элементы от краев окна и друг друга. 
Используем свойства padding и spacing. 
Первое отвечает за внешние отступы, второе — за пространство между элементами:
```
<Root>:
    orientation:'vertical'
    spacing: 6
    padding: 10
#code after …
```
Подобно отступам в html тут тоже можно задавать 
конкретное расстояние для каждой стороны элемента, но сейчас это излишне.
Так же добавим *spacing* равный шести для *GridLayout*, 
чтобы расположить кнопки ещё дальше друг от друга.
```
GridLayout:
        rows: 3
        cols: 2
        spacing:6
```				
Кажется, поле ввода занимает много места. Есть два способа изменить это. 
Способ первый: атрибут *size_hint*. 
Значение этого атрибута — пара чисел. Первое число отвечает 
за процент занимаемого места по оси Х, второе — по оси Y. 
Значение варьируется от 0 (минимум) до 1(максимум), и записывается как десятичная дробь. 
Дробь можно записывать без нуля в целой части. Ноль процентов также можно обозначить как None. 
Например, вот так мы заставим поле ввода занять половину 
ширины своего контейнера и минимум по высоте:
```
	TextInput:
        id: form
        multiline: False
        size_hint: .5,None
```        
Способо второй: если мы хотим поменять этот процент 
конкретно для оси Х или Y, мы используем свойство  
*size_hint_x* или *size_hint_y* соответственно. В данном случае мы напишем так:
```
	TextInput:
        id: form
        multiline: False
        size_hint_y: None 
```
Теперь изменим расположение текста в форме, снова используем свойство padding. 
Для Textinput это свойство задает расстояние от текста до границ поля. 
Вдоволь наигравшись с разными вариантами, остановимся на *self.height/2 * 0.4*.
```
TextInput:
        id: form
        multiline: False
        size_hint_y:None
        font_size: 40
        padding: self.height/2*0.4
```        
К сожалению, размер шрифта по умолчанию ужасно мал. Исправим это. 
У многих элементов, работающих с текстом, есть замечательное свойство font_size. 
Здесь хватит размера 40.
```
	TextInput:
        id: form
        multiline: False
        size_hint: 1,None
        padding: self.height/2*0.4
        font_size: 40
```
Изменим размер шрифта и для кнопок:
```
<ActionBtn@Button>:
    action: ''
    font_size: 40
```
Всё! С форматированием элементов закончено. 

###Финал

Наш калькулятор готов. Для простоты он будет считать все числа как float. 
В рамках статьи это не критично, но, если вы захотите, то без труда 
сможете добавить проверку типа самостоятельно.
Весь код урока можно посмотреть [здесь](./lessons/lesson-2/).
Надеюсь статья была для вас полезной и интересной. 
Смотрите примеры в [репозитарии Kivy](http://github.com/kivy.),
задавайте свои вопросы в [сообществе](http:/vk.com/kivy_ru). 
Спасибо за внимание и до новых встреч в следующих статьях!

