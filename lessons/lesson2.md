>##### Дисклеймер!
Настоятельно рекомендую прочитать предыдущую [статью](https://github.com/Hateman31/Kivy-magazine-ru/blob/master/lessons/lesson1.md)

## Мир вашему дому!

В этой статье мы научимся связывать разметку с кодом, 
создавать собственные виджеты и разбивать разметку 
на несколько модулей. И для этого мы сделаем всего лишь калькулятор.

###Поехали!

Калькулятор сможет выполнять стандартный набор из шести функций:  
* сложение
* вычитание 
* умножение 
* деление 
* извлечение корня 
* возведение в степень.

Мы будем вводить число, нажимать кнопку нужной операции, 
в поле ввода писать другое число и, после нажатия клавиши enter, 
получать внутри формы результат операции. 

Операции находятся в файле *toolkit.py*. Вот содержимое этого файла:
```python
def summ(x,y):
	return x+y

def sub(x,y):
	return x-y
	
def mul(x,y):
	return x*y

def div(x,y):
	return x/y

def pow_(x,y):
	return x**y

def root_(x,y):
	return x**(1/y)

func = {
	'summBtn': summ,	'subBtn': sub,
	'mulBtn': mul,	'divBtn':div,
	'powerBtn': pow_,	'rootBtn':root_
	}
```	
Извлечение корня может работать некорректно. Эта функция лишь пример работы с Kivy, 
поэтому не обращаем на неё особого внимания.

Переходим к самому приложению. Создаём файл *calculator.py* и пишем в него следующее:
```python
from kivy.app import App
from kivy.uix.boxlayout import BoxLayout
from kivy.uix.button import Button
import toolkit

class Calculator(BoxLayout):
	def operation(self):
		x = float(self.form.text)
		y = float(self.buf)
		self.form.text = str(toolkit.func[self.action](x,y))
		
class CalculatorApp(App):
	def build(self):
		return Calculator()

CalculatorApp().run()
```

Атрибут buf - это буфер для первого операнда, action - ключевое слово, 
по которому будет вызвана необходимая функция из модуля toolkit.py. 
Функцию operation будем вызывать после нажатия enter внутри формы ввода.
Атрибут *form* - форма в котороую будут выводиться результат.

Скрипт готов к применению. Cоздаем разметку.

###От простого к сложному

[В прошлом уроке](lesson1.md) 
мы научились вводить текст в форму 
и заставляли этот текст легко  меняться по нажатию кнопки. 
Калькулятор — немного усложнённая версия этой задачи. 
Но трудного ничего нет, потому что мы уже знаем, что:

* нам нужны *TextInput* и *Button*
* обращаться к одному виджету из другого можно, используя параметр *id*
* текст виджета задается через атрибут *text*
* действие кнопки задается через событие *on_press*

Создаём файл разметки *calculator.kv*. 
Калькулятор будет состоять из 6 кнопок и поля ввода. 
Начнём с поля ввода. *TextInput* по умолчанию работает в многострочном режиме. 
Чтобы отключить его, задаём свойству *multiline* значение ```False```. 
Чтобы обращаться к элементу form в скрипте, 
надо создать виджету *Calculator* атрибут *form*
и записать в этот атрибут индентификатор формы.
```
	<Calculator>:
		form: form
		TextInput:
			id: form
			multiline: False
```

Форму мы создали. К логике её работы ещё вернемся, а пока делаем кнопки.

###Пиши раз — используй многократно

Прежде чем добавить кнопки, немного подумаем. 
Все шесть кнопок работают идентично, 
поэтому метод *on_press* мы объявим 
один раз для всех шести объектов. 
Для этого создадим файл *action.kv* и добавим в него это:
```
<ActionBtn@Button>:
    action: ''
    on_press:
        app.root.buf = app.root.form.text
        app.root.form.text = ''
        app.root.action = self.action
```
Конструкция вида ```<class_name@widget_class>```— это , так называемый, 
динамический класс. Когда для однотипных виджетов, например кнопок, 
раз за разом приходится писать похожие параметры , 
достаточно создать динамический класс, унаследованный, 
скажем, от Button(для этого после @ мы указываем родительский класс), 
задать в нём значения повторяющихся атрибутов, 
а потом вместо дефолтного виджета вписать имя созданного класса.

Теперь по нажатию любой кнопки типа *ActionBtn*, текст элемента 
*form* будет считываться в *root.buf*, а его место -
занимать пустая строка. Атрибуту *action* виджета *Calculator* 
будет при этом присваиваться значение атрибута *action* нажатой кнопки.
Но  *ActionBtn* это самостоятельный класс, лежащий к тому же в отдельном файле.
Как же его связать с корневым виджетом *Calculator*?

В kivy есть три служебных слова: *self, app* и *root*. 
Что означают первые два - понятно. 
Третье тоже не вызывает вопросов, однако, не всё так просто. С одной стороны, 
root  — это корневой виджет. То есть по слову root мы получаем доступ к виджету, 
который является корневым для приложения. 
С другой стороны, root — это атрибут объекта app. 

*Root*, как корневой виджет, работает только внутри корневого элемента.
Если использовать *root* внутри динамического класса, то мы обратимся 
не к корневому виджету, а экземпляру этого класса. А вот служебное слово *app*
одинаково работает во всех частях приложения. В том числе в файлах разметки. 
А это значит,что любой виджет может обратиться к коревному виджету приложения как ```app.root```.  
Даже если виджет — динамический класс. Даже если он находится в отдельном файле.

Чтобы начать использовать *ActionBtn*, в начало файла *calculator.kv* добавляем строку:
```
#:include action.kv
```
Теперь добавляем кнопки в *Calculator*. Мы разместим кнопки в сетке 3x2. Для этого используем контейнер *GridLayout*: 
```
    GridLayout:
        rows: 3
        cols: 2
        ActionBtn:
            action:'summBtn'
            text:'x+y'
        ActionBtn:
            action:'subBtn'
            text:'x-y'
        ActionBtn:
            action:'mulBtn'
            text:'x*y'
        ActionBtn:
            action:'divBtn'
            text:'x/y'
        ActionBtn:
            action:'powerBtn'
            text:'x^y'
        ActionBtn:
            action:'rootBtn'
            text:'root(x,y)'
```
Кнопки готовы.

###Разделяй и властвуй

Пришло время задать логику работы формы.
Напомню общий алгоритм работы с программой:

1. вводим первое число 
2. нажимаем кнопку (поле очищается)
3. вводим второе число
4. нажимаем enter
5. получаем результат операции(текст формы меняется)

С пунктами *1* и *2* всё ясно. Переходим к оставшимся. 
Здесь нам надо отследить нажатие *enter* в *TextInput*, 
и, если в буфере уже есть число, то вызвать функцию *operation*.

В TextInput  есть такое событие *on_text_validate* - 
реагирует на нажатие *enter* ( работает **только** в однострочном режиме ). 
Используем условное выражение, чтобы проверить ```root.buf```:
```
#code before ...        
	TextInput:
        id: form
        multiline: False
        on_text_validate:
            if root.buf: root.operation()
#code after ...            
```
>####Важно !
>Kv очень трепетно отностится к отступам и переносам, 
>поэтому: если выражение короткое,пишите его в одну строку, 
>а если длинное, то не забудьте поставить бэкслэш после двоеточия, 
>а новую строку начать на том же уровне, что и условный оператор.

Поле ввода готово. Калькулятор уже в рабочем состоянии. И статью на этом можно
было бы окончить, но теперь когда наше детище наделено «умом», 
не лишним будет сделать его чуть симпатичней. 

###Добавим красоты

Для начала мы «отлепим» элементы от краев окна и друг друга. 
Используем свойства *padding* и *spacing*. 
Первое отвечает за внешние отступы, второе — за пространство между элементами:
```
<Root>:
    orientation:'vertical'
    spacing: 6
    padding: 10
#code after …
```
Здесь тоже как и в html можно задавать 
четыре расстояния для каждого элемента, но сейчас это не нужно.
Добавим ещё *spacing* равный шести для *GridLayout*, 
чтобы расположить кнопки ещё дальше друг от друга.
```
GridLayout:
        rows: 3
        cols: 2
        spacing:6
```				
Кнопки уже выглядят лучше. Посмотрим на поле ввода.
Кажется,оно занимает много места. Есть два способа изменить это. 
Способ первый: атрибут *size_hint*. 
Значение этого атрибута — пара чисел. Первое число отвечает 
за процент занимаемого места по оси Х, второе — по оси Y. 
Значение варьируется от 0 (минимум) до 1(максимум), и записывается как десятичная дробь. 
Дробь можно записывать без нуля в целой части. Ноль процентов также можно обозначить как None. 
Например, вот так мы заставим поле ввода занять половину 
ширины своего контейнера и минимум по высоте:
```
	TextInput:
        id: form
        multiline: False
        size_hint: .5,None
```        
Способо второй: если мы хотим поменять этот процент 
конкретно для оси Х или Y, мы используем свойство  
*size_hint_x* или *size_hint_y* соответственно. В данном случае мы напишем так:
```
	TextInput:
        id: form
        multiline: False
        size_hint_y: None 
```
В *Textinput* свойство *padding* задает расстояние от текста до границ поля.
Используем его:
```
TextInput:
        id: form
        multiline: False
        size_hint_y:None
        font_size: 40
        padding: self.height/2*0.4
```        
К сожалению, размер шрифта по умолчанию ужасно мал. Исправим это. 
У многих элементов, работающих с текстом, есть замечательное свойство *font_size*:
```
	TextInput:
        id: form
        multiline: False
        size_hint: 1,None
        padding: self.height/2*0.4
        font_size: 40
```
Изменим размер шрифта и для кнопок:
```
<ActionBtn@Button>:
    action: ''
    font_size: 40
```
Всё! С форматированием элементов закончено. 

###Финал

Наш калькулятор готов. Для простоты он будет считать все числа как ```float```. 
В рамках статьи это не критично, но, если вы захотите, то без труда 
сможете добавить проверку типа самостоятельно.


Надеюсь статья была для вас полезной и интересной. 
Весь код урока можно посмотреть [здесь](./lesson-2/).

Смотрите примеры в [репозитарии Kivy](http://github.com/kivy),
задавайте свои вопросы в [сообществе](http://vk.com/kivy_ru). 

Спасибо за внимание и до новых встреч в следующих статьях!

